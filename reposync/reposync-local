#!/usr/bin/perl
# Utilities for maintaining a number of repositories locally
# - incrementally updating packages as they become available

use strict;
use warnings;

use Getopt::Long;

my $gStop = 0;

sub INT_handler {
  $gStop = 1;
  print "Stopping...\n";
}

$SIG{'INT'} = 'INT_handler';


Getopt::Long::Configure('bundling');

sub show_usage(;$) {
  my $exit_code = shift;

  print "reposync-local [-h] [--list|-l]\n";
  print "  -l\tList available repos\n";
  print "  -h\tShow help\n";
  print "  repo=R\tSync specifies repositories, R\n";
  print "  option=O\tSpecify additional options for reposync\n";

  if (defined($exit_code)) {
    exit($exit_code);
  }
}

sub run_command($;$) {
  my $cmd = shift;
  my $outsubref = shift;
  my $donesubref = shift;

  print "Running $cmd".(defined($outsubref) || defined($donesubref) ? " (with callback)" : "")."\n";

  open(CMD_F, "$cmd 2>&1 | tee /dev/stdout |");

  while (!$gStop) {
    my $line = <CMD_F>;
    if (!defined($line)) {
      last;
    }

    if (defined($outsubref)) {
      $outsubref->($line);
    }
    else {
      print $line;
    }
  }

  if (!close(CMD_F)) {
    my @tok = split(/ /, $cmd);
    if ($! == 0) {
      # Command exited with error code
      my $ret = $? >> 8;

      print "Command $tok[0] exited with $ret\n";

      if (defined($donesubref)) {
        $donesubref->($ret);
      }

      return $ret;
    }
    else {
      print "Error reading output from command $tok[0]\n";
    }

    if (defined($donesubref)) {
      $donesubref->(0);
    }
    return 0;
  }

  if (defined($donesubref)) {
    $donesubref->(0);
  }

  return 1;
}

my %args;
my @repos;
my @opts;

my $reposync = `which reposync`;
chomp $reposync;

if ($reposync eq "") {
  print "No reposync available\n";
  exit(1);
}


if (!GetOptions('help|h' => \$args{help},
                'list|l' => \$args{list},
                'repo=s' => \@repos,
                'option=s' => \@opts)) {
  show_usage(1);
}

if ($args{help}) {
  show_usage(0);
}

if ($args{list}) {
  run_command('yum repolist all');
  exit(0);
}

sub reposync_callback($) {
  my $line = shift;

print "zzz $line\n";


  if ($line !~ m/%/) {
    print "reposync: $line";
    
  }

  if ($line =~ m/Downloading|Error/) {
    print "PPPPP $line\n";
  }


}



print "reposync-local\n";

foreach my $r (@repos) {
  print "Syncing Repo $r\n";
  
  run_command("$reposync --repoid=$r @opts", \&reposync_callback);


}

# run command and get output in callback
#sub callback($) {
#  my $line = shift;
#  print "CB $line\n";
#}
#run_command('./bad a b c d e f', \&callback);
